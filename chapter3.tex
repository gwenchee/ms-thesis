\chapter{Methods}
\label{chap:3}
In this chapter, the \gls{NFC} simulators utilized in this work
, \Cyclus and DYMOND, and the new capabilities developed for 
\gls{NFC} simulators are described. 
The new capabilities are: 
(1) demand-driven deployment capabilities in \Cyclus, 
(2) sensitivity analysis capabilities for DYMOND, and
(3) sensitivity analysis capabilities for \Cyclus. 

\section{\Cyclus}
\Cyclus is an agent-based nuclear fuel cycle simulation framework 
\cite{huff_fundamental_2016}. 
In \Cyclus, each entity (i.e. Region, Institution, or Facility) in 
the fuel cycle is an agent. 
Region agents represent geographical or political areas that institution
and facility agents can be grouped into. 
Institution agents control the 
deployment and decommission of facility agents 
and represent legal operating organizations such as a 
utility, government, etc. \cite{huff_fundamental_2016}. 
Facility agents represent nuclear fuel cycle facilities. 
\Cycamore \cite{carlsen_cycamore_2014}
provides facility agents to represent process physics of various 
components in the nuclear fuel cycle (e.g. mine, fuel enrichment 
facility, reactor). 
The \Cycamore reactor model uses externally-calculated 
recipes for fresh and spent fuel compositions. 
The mass flows and inventories are recorded at an agent level
and individual isotopes are tracked. 

% Describe the agent-based model and flexibility
Two of \Cyclus' main design objectives are user customization and 
extensibility. 
These objectives are achieved through \Cyclus' modularity, 
open architecture, and agent interchangeability. 
The modularity and open architecture provide users with a 
platform to develop custom facilities with their chosen fidelity 
and capabilities. 
Agent interchangeability facilitates configuration of custom fuel 
cycles and direct comparisons of alternative modeling methodologies 
and facility concepts \cite{huff_fundamental_2016}. 
\Cyclus' input file has an XML format and the output file is 
a SQL database. 

\section{DYMOND}
DYMOND \cite{yacout_modeling_2005} is a \gls{NFC} simulator developed 
at Argonne National Laboratory (\gls{ANL}). 
It is built using the AnyLogic simulation software with 
Microsoft Excel templates for data input and output. 
The major inputs to this code are time-dependent power demand, 
reactor and fuel cycle characteristics 
\cite{feng_standardized_2016}.   
The code calls ORIGEN \cite{bell_origen_1973} during the simulation 
to conduct reactor depletion calculations. 
The mass flows and inventories are recorded at a system level
and individual isotopes are tracked. 
DYMOND's main design objective is ease of understanding the  
simulator's behavior and variables. 

In DYMOND, reactor facilities are automatically deployed to 
meet a user-defined power demand and the user can define 
the percentage share of energy for up to five reactor types. 
The user also defines the fuel loading model used to calculate 
reactor spent fuel compositions, the type of reprocessing 
technology that is used for each reactor type, and the length 
of used fuel cooling time. 
In DYMOND, the user must define the deployment schedule for 
the reprocessing plants; the cooling pools and storage pools 
are all assumed to have infinite capacities. 
DYMOND does not have demand-driven deployment capabilities for 
supporting fuel cycle facilities. 

The difference between \Cyclus and DYMOND is that \Cyclus uses 
agent-based modeling for all facilities and mass flows, 
whereas DYMOND uses fleet-based modeling for all facilities and 
mass flows with exception of reactor facilities. 
Compared to \Cyclus, DYMOND is easier to use but less flexible. 

\section{Demand driven deployment capability in \Cyclus (\deploy)}
In 2016, there was a push from the DOE to understand and evaluate the 
transition from the initial EG01 state to promising future 
end-states \cite{feng_standardized_2016}.
Previously in \Cyclus, reactor facilities were automatically 
deployed to meet a user-defined power demand. 
However, the user was required to define a deployment scheme of 
supporting facilities to ensure that there would be no supply chain 
gap resulting in idle reactor capacity. 
To avoid this issue, users 
have to set infinite capacities for the support facilities, 
but this is an inaccurate representation of reality. 
Another option is to manually calculate a suitable deployment 
schedule. 
It is straightforward to manually determine a deployment scheme 
for a once-through fuel cycle, however, it is not straightforward
for complex closed fuel cycle scenarios.  
To ease setting up realistic \gls{NFC} simulations, a \gls{NFC} simulator
should bring demand-responsive deployment decisions into 
the simulation logic dynamics \cite{huff_current_2017}. 
Thus, a next-generation \gls{NFC} simulator should automate 
transition scenario setup by predictively and 
automatically deploying fuel cycle facilities to meet a user-defined 
power demand. 
Therefore, Demand-Driven Cycamore Archetypes project
(NEUP-FY16-10512) was initiated to develop demand-driven deployment 
capabilities in \Cyclus.
This capability, \deploy, is a \Cyclus \texttt{Institution}
agent that deploys facilities to meet user-defined power demand. 

\subsection{\deploy framework}
\label{sec:d3ploy}
In \Cyclus, developers have the option to design 
agents using C++ or Python. 
The \deploy \texttt{Institution} agent was 
implemented in Python to enable the use of 
well-developed time series forecasting Python packages. 

In a \Cyclus \gls{NFC} simulation, at every time step, \deploy 
predicts the supply and demand of each commodity for the next time 
step. 
When there exists undersupply for any commodity, 
\deploy deploys facilities to meet its predicted demand.
Figure \ref{fig:flow} shows the logic flow of \deploy 
at every time step. 

\begin{figure}[]
    \centering
    \begin{tikzpicture}[node distance=2.7cm]
        \tikzstyle{every node}=[font=\large]
        \node (Start) [bblock] {\textbf{Start timestep ($t$).}};
        \node (Predict) [bblock, below of=Start] {\textbf{Calculate \\ $D_p(t+1)$ and \\ $S_p(t+1)$ for a commodity}};
        \node (IsThere) [oblock, below of=Predict]{\textbf{$U(t+1) = S_p(t+1)-D_p(t+1)$}};
        \node (Deploy) [sbblock, below of=IsThere, xshift = -3.5cm]{\textbf{Deploy Facilities}};
        \node (NoDeploy) [sbblock, right of=Deploy, xshift = 3.5cm]{\textbf{No Deployment} };
        \node (All) [oblock, below of=Deploy, xshift = 3.5cm] {\textbf{Has $D_p(t+1)$ and $S_p(t+1)$ been calculated for all commodities?}};
        \node (End) [bblock, below of=All] {\textbf{Proceed to next timestep.}};
        
        \draw [arrow] (Start) -- (Predict); 
        \draw [arrow] (Predict) -- (IsThere);
        \draw [arrow] (IsThere) -- node[anchor=east] {$U(t+1) <$ buffer} (Deploy);
        \draw [arrow] (IsThere) -- node[anchor=west] {$U(t+1) \geq$ buffer} (NoDeploy);
        \draw [arrow] (Deploy) -- (All);
        \draw [arrow] (NoDeploy) -- (All);
        \draw [arrow] (All) -- node[anchor=west] {yes} (End);
        \draw [arrow] (All) -- ([shift={(-3.8cm,0.9cm)}]All.south west)-- node[anchor=east] {no} ([shift={(-3.8cm,-1.05cm)}]Predict.north west)--(Predict);
        \draw [arrow] (End) |-([shift={(3cm,-0.5cm)}]End.south east)-- ([shift={(3cm,0.5cm)}]Start.north east)-|(Start);
    \end{tikzpicture}
    \caption{\deploy logic flow at every timestep in \Cyclus \cite{chee_demonstration_2019}.}
    \label{fig:flow}
\end{figure}

\deploy aims to minimize the undersupply of power (Equation \ref{eq:pow}).
\begin{align}
	\label{eq:pow}
	obj = min \sum_{t=1}^{t_{end}} |D_{t,power}-S_{t,power}|
\end{align} 
The sub-objectives are (1) to minimize the number of time 
steps of undersupply or under-capacity of any 
commodity: 
\begin{align}
	\label{eq:sub1}
	obj = min \sum_{i=c_1}^{c_M}\sum_{t=1}^{t_N} |D_{t,i}-S_{t,i}|,
\end{align}
(2) to minimize excessive oversupply of all commodities: 
\begin{align}
	\label{eq:sub2}
	obj &= min \sum_{i=c_1}^{c_M}\sum_{t=1}^{t_N} |S_{t,i}-D_{t,i}|.
	\intertext{where:}
	D &= \mbox{Demand} \nonumber\\
	S &= \mbox{Supply} \nonumber\\
	c &= \mbox{Commodity type} \nonumber\\
	M &= \mbox{Number of commmodities} \nonumber\\
	N &= \mbox{Number of time steps} \nonumber
\end{align} 
Minimizing excessive oversupply 
reflects reality in which utilities avoid 
undersupply of power on the grid by ensuring power 
plants are never short of fuel while avoiding expensive oversupply.
\gls{NFC} simulators often face power undersupplies 
due to lack of viable fuel, despite having sufficient installed 
reactor capacity.  
Using \deploy to automate the deployment of supporting 
facilities prevents this. 

\subsubsection{\textbf{Structure}}
In \deploy, two distinct institutions control 
front-end and back-end fuel cycle facilities: 
\texttt{DemandDrivenDeploymentInst} and 
\texttt{SupplyDrivenDeploymentInst}, respectively. 
The reason for this distinction is that front-end facilities 
meet the demand for commodities they produce, whereas back-end 
facilities meet supply for the commodities they demand. 
For example, when a reactor facility 
demands fuel, \texttt{DemandDrivenDeploymentInst}
deploys fuel fabrication facilities to create fuel
supply. 
For back-end facilities, the reactor generates spent fuel, and 
\texttt{SupplyDrivenDeploymentInst} deploys 
waste storage facilities to create capacity to store the spent fuel. 
Figure \ref{fig:insts} depicts a simple once-through fuel cycle 
and the \texttt{Institution} type governing each 
facility's deployment.  

\begin{figure}[]
	\centering
\begin{tikzpicture}[node distance=3cm,auto,>=latex']
	\tikzstyle{every node}=[font=\scriptsize]
    \node [bbslock] (a) {Source};
    \node [bbslock] (b) [right of=a] {Enrichment \\ Facility};
	\node [bbslock] (c) [right of=b] {Reactor};
	\node [obslock] (d) [right of=c] {Cooling \\ Pool};
	\node [obslock] (e) [right of=d] {Sink};
    \path[->] (a) edge node {Natl U} (b);
	\draw[->] (b) edge node {Fuel} (c) ;
	\draw[->] (c) edge node {\shortstack{Used \\ Fuel}} (d) ;
	\draw[->] (d) edge node {\shortstack{Cooled \\ Used \\ Fuel}} (e) ;
\end{tikzpicture}
\resizebox{0.5\textwidth}{!}{
    \fbox{\begin{tabular}{ll}
        \textcolor{illiniblue}{$\blacksquare$} & Deployed by \texttt{DemandDrivenDeploymentInst}\\
        \textcolor{illiniorange}{$\blacksquare$} & Deployed by \texttt{SupplyDrivenDeploymentInst} 
		\end{tabular}}}
		\caption{Simple once-through fuel cycle depicting which facilities are deployed by 
		\texttt{DemandDrivenDeploymentInst} and \texttt{SupplyDrivenDeploymentInst}.}
\label{fig:insts}
\end{figure}

\subsubsection{\textbf{Deployment Driving Method}}
The user may deploy facilities based on the difference 
between predicted demand and predicted supply, \textit{or}
predicted demand and installed capacity. 
Using installed capacity instead of predicted supply
has two advantages. 
First, to prevent over-deployment of facilities with an
intermittent supply such as reactors that require refueling. 
If predicted supply is selected instead of installed capacity, 
\deploy will deploy surplus reactors during refueling downtimes to 
meet the temporary power undersupply.
Second, to prevent infinite deployment of a facility that demands 
a commodity no longer available in the simulation. 
For example, a reprocessing plant that fabricates Sodium-Cooled Fast Reactor 
(SFR) fuel might demand Pu after depletion of the existing Pu inventory and 
decommissioning of the LWR reactors that produce it, resulting in 
infinite deployment of reprocessing facilities in a futile attempt 
to produce SFR fuel. 

\subsubsection{\textbf{Input Variables}}
Table \ref{tab:inputs} lists and gives examples of the input 
variables \deploy accepts. 
The user must do the following: 
define the facilities in the simulation, their respective 
capacities, the demand driving commodity,
its demand equation, the deployment driving method, 
and prediction method. 
The user also has the option to define supply/capacity buffers 
for individual commodities, facility preferences, and facility 
fleet shares. 
The subsequent sections describes 
the buffers, facility preferences, and prediction methods. 

\begin{table}[]
    \centering
    \caption{\deploy's required and optional input parameters with examples.}
    \label{tab:inputs}
        \footnotesize
        \begin{tabular}{l|ll}
        \hline
            & \textbf{Input Parameter}                                                           & \textbf{Examples}                                                                                                          \\ \hline
            \multirow{5}{*}{\textbf{Required}} & Demand driving commodity                                                           & Power                                                                                                                      \\ \cline{2-3} 
                                                      & Demand equation                                                                    & P(t) = 10000, sin(t), 10000*t                                                                                                                 \\ \cline{2-3} 
                                                      & Facilities it controls                                                             & Fuel Fab, LWR reactor, Sink, etc.                                                                                                      \\ \cline{2-3} 
                                                      & Capacities of the facilities                                                       & 3000 kg, 1000 MW, 50000 kg                                                                                                     \\ \cline{2-3} 
                                                      & Prediction method                                                                  & \begin{tabular}[c]{@{}l@{}}Power: fast fourier transform\\ Fuel: moving average\\ Spent fuel: moving average\end{tabular} \\ \cline{2-3} 
                                                      & Deployment driven by & Installed Capacity                                                                                                                    \\ \hline
            \multirow{4}{*}{\textbf{Optional}} & Supply/Capacity Buffer type                                                                        & Absolute                                                                                                                  \\ \cline{2-3} 
                                                      & Supply/Capacity Buffer size                                                                        & \begin{tabular}[c]{@{}l@{}}Power: 3000 MW\\ Fuel: 0 kg \\ Spent fuel: 0 kg\end{tabular}                                   \\ \cline{2-3} 
                                                      & Facility preferences                                                               & \begin{tabular}[c]{@{}l@{}}LWR reactor = 100-t\\ SFR reactor = t-100 \end{tabular}          \\ \cline{2-3} 
                                                      & Fleet share percentage                                                            & \begin{tabular}[c]{@{}l@{}}MOX LWR = 85\%\\ SFR = 15\% \end{tabular}          \\ \hline
                    \end{tabular}
\end{table}
    
    \subsubsection{\textbf{Supply/Capacity Buffer}}
    In \texttt{DemandDrivenDeploymentInst}, the user has the option to specify a 
    supply buffer for each commodity; \deploy accounts for the buffer when 
    calculating predicted demand and deploys facilities accordingly.
    In \texttt{SupplyDrivenDeployment}
    
    \noindent 
    \texttt{Inst},
    the user has the option to specify a capacity buffer for specific 
    commodities; d3ploy accounts for the buffer when calculating predicted 
    supply and deploys facilities accordingly. 
    The buffer is defined as a percentage (equation \ref{eq:perc}) 
    or absolute value (equation \ref{eq:abs}). 
    
    \begin{align}
        \label{eq:perc}
        S_{pwb} &= S_{p}(1+d)\\
        \label{eq:abs}
        S_{pwb} &= S_{p}+a \\
        \intertext{where:}
        S_{pwb} &= \mbox{predicted supply/capacity with buffer} \nonumber\\
        S_p &= \mbox{predicted supply/capacity without buffer} \nonumber\\
        d &= \mbox{percentage value in decimal form} \nonumber\\
        a &= \mbox{absolute value of the buffer} \nonumber
    \end{align}
    For example, the user sets the power commodity's absolute supply buffer 
    to be 2000 MW and predicted demand is 10000 MW, \deploy deploys reactor 
    facilities to meet the predicted demand and supply buffer, resulting 
    in a power supply of: 
    \begin{align*}
        S_{pwb} &= S_{p}+a \\
        S_{pwb} &= 10000 \mbox{MW}+2000 \mbox{MW} \\
        &= 12000\mbox{MW}
    \end{align*}
    Using a combination of the buffer capability and  
    installed capacity deployment driving method in a transition 
    scenario simulation effectively minimizes undersupply of a 
    commodity while avoiding excessive oversupply. 
    This is demonstrated in section \ref{sec:demo}. 
    
    \subsubsection{\textbf{Facility Preference and Fleet Share}}
    The user has the option to give preferences to facilities' 
    that supply the same commodity. 
    These preferences are in the form of a time-dependent 
    equation so that the preferences can be dynamic with time. 
    \deploy uses these equations to determine which facility 
    to deploy during a commodity shortage.  
    In table \ref{tab:inputs}, 
    the \gls{LWR} reactor has a preference of $100-t$, and the 
    \gls{SFR} reactor has a preference of $t-100$. 
    At time step 1, LWR preference is 99, while SFR preference is -99; 
    therefore a LWR is deployed if there is a commodity shortage. 
    At time step 105, LWR preference is -5, while SFR preference is 5; 
    therefore a SFR is deployed if there is a commodity shortage. 

    The user also has the option to specify percentage-share for facilities 
    that provide the same commodity.   
    In table \ref{tab:inputs}, 
    the \gls{MOX} \gls{LWR} has a share of 85\%, while 
    the \gls{SFR} has a share of 15\%. 
    This constrains \gls{SFR} deployment to 85\% of total power demand 
    and \gls{MOX} \gls{LWR} deployment to 15\% of total power demand.  

    The year the transition begins is selected by customizing facility 
    preferences to begin preference for advanced reactors at a certain year,
    and the sharing capability determines the percentage 
    share of each type of reactor to transition to. 
    Therefore, when \deploy predicts an undersupply of a commodity 
    it deploys facilities in order of preference, starting at 
    the highest and moving down if the facility percentage share 
    is already met. 
    If a facility type does not have any preferences, \deploy 
    deploys available facilities to minimize the number of deployed 
    facilities and oversupply of the commodity.

\subsubsection{\textbf{Prediction Methods}}
\deploy records supply and demand values at each time step for all 
commodities to provide time-series data for \deploy's time series 
forecasting methods to predict future supply and demand for each 
commodity.  
The time series forecasting methods investigated include non-optimizing, 
deterministic-optimizing, and stochastic-optimizing methods. 
Non-optimizing methods are techniques that harness 
simple moving average and autoregression concepts which use 
historical data to infer future supply and demand values. 
Deterministic-optimizing and stochastic-optimizing 
methods are techniques 
that use an assortment of more sophisticated time series forecasting 
concepts to predict future supply and demand values. 
Deterministic-optimizing methods give deterministic solutions,
while stochastic-optimizing methods give stochastic solutions. 

Depending on the scenario in question, each forecasting method 
offers distinct benefits and disadvantages.
The various methods are compared for each type of simulation 
to determine the most effective prediction method for 
a given scenario. 
The following sections describe the prediction methods. 

\noindent
\textit{Non-Optimizing Methods}

Non-optimizing methods include: Moving Average (\texttt{MA}), 
Autoregressive Moving Average (\texttt{ARMA}), and 
Autoregressive Heteroskedasticity (\texttt{ARCH}). 
The \texttt{MA} method calculates the average of 
a user-defined number of previous entries in a commodity's 
time series and returns it as the predicted value 
(equation \ref{eq:ma}).

\begin{equation}
	\label{eq:ma}
	Predicted\ Value = \frac{V_1+V_2+...+V_n}{n}
\end{equation}

The \texttt{ARMA} method combines moving average and
autoregressive models (equation \ref{eq:arma}).
The first term is a constant, second term is 
white noise, the third term is the autoregressive
model, and the fourth term is the moving average
model.
The \texttt{ARMA} method is more accurate than the 
\texttt{MA} method 
because of the inclusion of the autoregressive term. 

\begin{equation}
	\label{eq:arma}
	X_t = c + \epsilon_t + 
	\sum_{i=1}^p\varphi_i X_{t-i} +	
	\sum_{i=1}^q\theta_i\epsilon_{t-i}
\end{equation}

The \texttt{ARCH} method modifies the original moving 
average term (described in equation \ref{eq:arma}). 
This modification makes the \texttt{ARCH} method 
better than the \texttt{ARMA} method for volatile 
time-series data \cite{flanagan_methods_2019}. 
The StatsModels \cite{github_community_statsmodels:_2019}
Python package is used to implement \texttt{ARMA} and 
\texttt{ARCH} methods in \deploy. 

\noindent
\textit{Deterministic-Optimizing Methods}

Deterministic methods include
Fast Fourier Transform (\texttt{FFT}), 
Polynomial Fit (\texttt{POLY}), 
Exponential Smoothing (\texttt{EXP-SMOOTHING}), 
and Triple Exponential Smoothing (\texttt{HOLT-WINTERS}). 
The \texttt{FFT} method computes the discrete Fourier transform 
of the time series to predict future demand and supply 
values (equation \ref{eq:fft}).
This method is implemented in \deploy using the 
SciPy \cite{jones_scipy:_2016} Python package. 

\begin{equation}
	\label{eq:fft}
	X_k = \sum_{n=0}^{N-1}x_n e^{-i2\pi kn/N}
\end{equation}

The \texttt{POLY} method models the time series data 
with a user-defined nth degree polynomial to determine 
future demand and supply values. 
This method was implemented in \deploy using the 
NumPy \cite{developers_numpy_2013} Python package. 
The \texttt{EXP-SMOOTHING} and \texttt{HOLT-WINTERS} 
methods use a weighted average 
of time-series data with exponentially decaying weights 
for older time series values \cite{hyndman_forecasting:_2018}
to create a model to determine future demand and supply values. 
The \texttt{EXP-SMOOTHING} method excels in 
modeling univariate time series data without trend or seasonality, 
whereas the \texttt{HOLT-WINTERS} method applies exponential 
smoothing three times, resulting in higher accuracy when 
modeling seasonal time series data. 
The StatsModels \cite{github_community_statsmodels:_2019}
Python package was used to implement both of these methods 
in \deploy. 

\noindent
\textit{Stochastic-Optimizing Methods}

There is one stochastic-optimizing method: step-wise 
seasonal method (\texttt{SW-SEASONAL}). 
The method was implemented in \deploy by the auto \gls{ARIMA} 
method in the pmdarima \cite{noauthor_pmdarima:_2019}
Python package. 
The \gls{ARIMA} model is a generalization of the \gls{ARMA}
model to make the model fit the time series data better. 

\section{Sensitivity Analysis Capabilities}
In this work, \Cyclus and DYMOND are coupled with Dakota 
\cite{eldred_dakota_2010} to give the \gls{NFC} simulators 
Sensitivity Analysis (\gls{SA}), 
Uncertainty Quantification (\gls{UQ}), and optimization capabilities. 
Dakota is used in conjunction with \Cyclus and DYMOND because it 
is a well supported \gls{SA}, \gls{UQ}, 
and optimization tool that provides a flexible interface between 
analysis codes and iterative system analysis methods 
\cite{turner_virtual_nodate}. 
It has also previously been coupled with other nuclear engineering 
software \cite{turner_virtual_nodate,zhang_uncertainty_nodate}. 

The process of coupling with Dakota is similar 
for both \gls{NFC} simulators. 
The coupling is depicted in Figure \ref{fig:dakota-NFC-flow}; 
Dakota is applied as a wrapper around each of the \gls{NFC} simulators. 
In this work, a Python interface between Dakota and the \gls{NFC} simulators
is developed. 
The Python interface has three functions: 
(1) edit the \gls{NFC} simulator's input file based on Dakota's input values, 
(2) run the simulation with the newly edited \gls{NFC} simulator's input file, and 
(3) read the \gls{NFC} simulator's output file and returns values of interest 
to the Dakota output file. 
The parameters for the \gls{SA}, \gls{UQ}, or optimization study 
is defined in the Dakota input file. 
The differences in the Python interface between Dakota and each 
\gls{NFC} simulator lies in the writing to and reading of 
each of their input and output files. 

\begin{figure}[]
    \centering
    \begin{tikzpicture}[node distance=4.5cm]
        \tikzstyle{every node}=[font=\large]
        \node (one) [sbblock,text width=4cm]{\small Dakota input file};
    \node (two) [bblock, right of=one, xshift = 1cm, text width=5cm]{\scriptsize Python Script\begin{itemize}
        \item Edit NFC code input file with Dakota's inputs 
        \item Run NFC code with new input file 
        \item Read NFC code database for selected output variable
    \end{itemize}};
    \node  (three) [sbblock, xshift = 1cm, right of=two,text width=4cm]{\small Dakota output file};
        
        \draw [arrow] (one) -- (two);
        \draw [arrow] (two) -- (three);
        \draw [arrow] (three) |-([shift={(0cm,-1.5cm)}]three.south west)-- ([shift={(0cm,-1.5cm)}]one.south east)-|(one);
    \end{tikzpicture}
    \caption{Depiction of coupling of Dakota and NFC code}
    \label{fig:dakota-NFC-flow}
\end{figure}

\subsection{DYMOND-Dakota Coupling (\texttt{ddwrapper})}
% python scripts to parse the excel input and output templates 
In the interface between DYMOND and Dakota, the Pywin32 
\cite{hammond_python_2000}
Python package is used to parse the Excel input file to 
write to the relevant Excel cells accordingly. 
Pywin32 is a thin Python wrapper that enables interaction 
with COM objects \cite{hammond_python_2000}. 
The Pandas \cite{mckinney_pandas:_2011} Python
package is used to analyze the excel output database 
by taking the values of interest and formatting them 
to return to the dakota output file.
The scripts coupling DYMOND and Dakota are demonstrated in the 
\texttt{ddwrapper} github repository \cite{chee_gwenchee/ddwrapper_2019}.

\subsection{\Cyclus-Dakota Coupling (\texttt{dcwrapper})}
% python scripts + jinja2 for input 
% python scripts + cymetric for output 
In the interface between \Cyclus and Dakota, 
the Jinja2 \cite{ronacher_welcome_2018} Python package is used 
to edit the relevant parts of a \Cyclus XML input file. 
Jinja2 is a modern and designer-friendly templating 
language for Python. 
The \Cyclus output database is analyzed with
the \textsc{Cymetric} Python \cite{scopatz_cymetric_2015} package. 
\textsc{Cymetric} is a general analysis library and tool that was 
created in 2015 to more easily interact with \Cyclus' SQL 
database. 
The scripts coupling \Cyclus and Dakota are demonstrated in the 
\texttt{dcwrapper} github repository \cite{chee_arfc/dcwrapper_2019}.

% Add github doi 


