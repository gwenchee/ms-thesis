\chapter{Methods}
\label{chap:3}
In this chapter, the \glspl{NFCSim} used in this work 
, \Cyclus and DYMOND, and the new capabilities developed for 
\glspl{NFCSim} are described. 
The new capabilities are: 
(1) demand-driven deployment capabilities in \Cyclus, 
(2) sensitivity analysis capabilities for DYMOND, and
(3) sensitivity analysis capabilities for \Cyclus. 

\section{\Cyclus}
\Cyclus is an agent-based nuclear fuel cycle simulation framework 
\cite{huff_fundamental_2016}. 
In \Cyclus, each entity (i.e. Region, Institution, or Facility) in 
the fuel cycle is an agent. 
Region agents represent geographical or political areas that institution
and facility agents can be grouped into. 
Institution agents control the 
deployment and decommission of facility agents 
and represents legal operating organizations such as a 
utility, government, etc. \cite{huff_fundamental_2016}. 
Facility agents represent nuclear fuel cycle facilities. 
\Cycamore \cite{carlsen_cycamore_2014}
provides facility agents to represent process physics of various 
components in the nuclear fuel cycle (e.g. mine, fuel enrichment 
facility, reactor). 
The \Cycamore reactor model uses externally-calculated 
recipes for fresh and spent fuel compositions. 
The mass flows and inventories are recorded at an agent-level
and individual isotopes are tracked. 

% Describe the agent-based model and flexibility
Two of \Cyclus' main design objectives are user customization and 
extensibility. 
These objectives are achieved through \Cyclus' modularity, 
open architecture, and agent interchangeability. 
The modularity and open architecture provides users with a 
platform to develop custom facilities with their chosen fidelity 
and capabilities. 
Agent interchangeability facilitates setting up of custom fuel 
cycles and direct comparisons of alternative modeling methodologies 
and facility concepts \cite{huff_fundamental_2016}. 
\Cyclus' input file has an XML file format and the output file is 
a SQL database. 

\section{DYMOND}
DYMOND \cite{yacout_modeling_2005} is a \gls{NFCSim} developed 
at \gls{ANL}. 
It is built using the AnyLogic simulation software with 
Microsoft Excel templates for data input and output. 
The major inputs to this code are reactor and fuel cycle 
characteristics, and time-dependent power demand 
\cite{feng_standardized_2016}.   
The code calls ORIGEN \cite{bell_origen_1973} during the simulation 
to conduct reactor depletion calculations. 
The mass flows and inventories are recorded at a system-level
and individual isotopes are tracked. 
DYMOND's main design objective is ease of understanding its 
behavior and variables. 

In DYMOND, reactor facilities are automatically deployed to 
meet a user-defined power demand and the user can define 
the targeted shares of energy for up to five reactor types. 
The user also defines the fuel loading model used to calculate 
reactor spent fuel compositions, the type of reprocessing 
technology that is used for each reactor type, and the length 
of used fuel cooling time etc. 
In DYMOND, the user must define the deployment schedule for 
the reprocessing plants and the cooling pools and storage pools 
are all assumed to have infinite capacities. 
DYMOND does not have demand-driven deployment capabilities for 
supporting fuel cycle facilities. 

The difference between \Cyclus and DYMOND is that \Cyclus uses 
agent-based modeling for all facilities and mass flows, 
whereas DYMOND uses fleet-based modeling for all facilities and 
mass flows with exception of reactor facilities. 
\Cyclus has the advantage of flexibility and customization, 
and DYMOND has the advantage of ease of use. 

\section{Demand driven deployment capability in \Cyclus (\deploy)}
In 2016, there was a push to understand and evaluate the 
transition from the initial EG01 state to promising future 
end-states \cite{feng_standardized_2016}.
Previously in \Cyclus, reactor facilities are automatically 
deployed to meet a user-defined power demand. 
However, it is up to the user to define a deployment scheme of 
supporting facilities to ensure that there is no gap in the supply 
chain that results in idle reactor capacity. 
To avoid this issue, users 
have to set infinite capacities for the support facilities, 
but this is an inaccurate representation of reality. 
Another option is to manually calculate a suitable deployment 
schedule. 
It is straightforward to manually determine a deployment scheme 
for a once-through fuel cycle, however, it is difficult to effectively 
implement for complex closed fuel cycle scenarios.  
Therefore, to successfully conduct analysis of the time-dependent 
closed fuel cycle transition
analyses, it is necessary to develop \gls{NFCSim} tools to  
automate setting up of transition scenarios. 
Therefore, Demand-Driven Cycamore Archetypes project
(NEUP-FY16-10512) was initiated to develop demand-driven deployment 
capabilities in \Cyclus.
This capability is added as a \Cyclus Institution
agent that deploys facilities to meet the front-end and back-end 
fuel cycle demands based on a user-defined commodity demand. 
This demand-driven deployment capability is called 
\deploy. 

\subsection{\deploy framework}
\label{sec:d3ploy}
In a \Cyclus simulation, at every timestep, \deploy 
predicts supply and demand of each commodity for the next time 
step. 
If there is an undersupply of any commodity based 
on the predicted values, \deploy deploys facilities to meet 
the predicted demand.  
Figure \ref{fig:flow} shows the logic flow of \deploy 
at every timestep. 

\begin{figure}[]
    \centering
    \caption{\deploy logic flow at every timestep in \Cyclus \cite{chee_demonstration_2019}.}
    \label{fig:flow}
    \begin{tikzpicture}[node distance=2.5cm]
        \tikzstyle{every node}=[font=\large]
        \node (Start) [bblock] {\textbf{Start of timestep ($t$).}};
        \node (Predict) [bblock, below of=Start] {\textbf{Calculate \\ $D_p(t+1)$ and $S_p(t+1)$ for a commodity}};
        \node (IsThere) [oblock, below of=Predict]{\textbf{$U(t+1) = S_p(t+1)-D_p(t+1)$}};
        \node (Deploy) [sbblock, below of=IsThere, xshift = -3.5cm]{\textbf{Deployment \\ of facility}};
        \node (NoDeploy) [sbblock, right of=Deploy, xshift = 3.5cm]{\textbf{No Deployment} };
        \node (All) [oblock, below of=Deploy, xshift = 3.5cm] {\textbf{Is this done for all commodities?}};
        \node (End) [bblock, below of=All] {\textbf{Proceed to next timestep.}};
        
        \draw [arrow] (Start) -- (Predict); 
        \draw [arrow] (Predict) -- (IsThere);
        \draw [arrow] (IsThere) -- node[anchor=east] {$U(t+1) <$ buffer} (Deploy);
        \draw [arrow] (IsThere) -- node[anchor=west] {$U(t+1) \geq$ buffer} (NoDeploy);
        \draw [arrow] (Deploy) -- (All);
        \draw [arrow] (NoDeploy) -- (All);
        \draw [arrow] (All) -- node[anchor=west] {yes} (End);
        \draw [arrow] (All) -- ([shift={(-3.9cm,0.7cm)}]All.south west)-- node[anchor=east] {no} ([shift={(-3.9cm,-0.85cm)}]Predict.north west)--(Predict);
        \draw [arrow] (End) |-([shift={(3cm,-0.5cm)}]End.south east)-- ([shift={(3cm,0.5cm)}]Start.north east)-|(Start);
    \end{tikzpicture}
\end{figure}

\deploy's overall objective is to ensure that there is no 
undersupply of power. 
The sub-objectives are : (1) to minimize the number of time 
steps of undersupply or under capacity of any 
commodity, (2): to minimize excessive oversupply of all commodities.
This is a reflection of reality in which it is important to 
never have an undersupply of power on the grid by ensuring power 
plants are never undersupplied of fuel, while not 
having excessive over supply resulting in a burden to store unused 
supplies. 
One of the key issues that \gls{NFCSim}s face is that despite
sufficient installed reactor capacity to meet the power 
demand, there is insufficient supply of fabricated/reprocessed 
fuel at certain timesteps, resulting in idle capacity.  

\subsection{\textbf{Structure}}
%Description of front end and back end of fuel cycle 
%Demand Driven vs. Supply Driven 
In \deploy, two different institutions were implemented for 
front-end and back-end fuel cycle facilities: 
\texttt{DemandDrivenDeploymentInst} and 
\texttt{SupplyDriven} 
\noindent
\texttt{DeploymentInst} respectively. 
This distinction was made because front-end facilities 
are deployed to meet demand for the commodity they produce. 
Whereas, back-end facility are deployed to meet supply for the 
commodity they provide capacity for. 
For example, for front end facilities, a reactor facility 
demands fuel and \texttt{DemandDrivenDeploymentInst} 
triggers deployment of fuel fabrication facilities to create 
supply meeting demand for fuel to prevent undersupply. 
For back end facilities, the reactor generates spent fuel and 
\texttt{SupplyDrivenDeploymentInst} triggers deployment of 
waste storage facilities to create capacity meeting the supply 
of spent fuel to prevent under capacity. 

\subsection{\textbf{Input Variables}}
Table \ref{tab:inputs} lists and gives examples of the input 
variables \deploy accepts. 
Essentially, the user must define the facilities controlled by 
\deploy, their respective capacities, the driving commodity, 
its demand equation, deployment driving method, and prediction method 
for supply and demand. 
The user also has the optional option to define supply/capacity buffers 
for each commodity, facility preferences, and facility constraints. 
In-depth descriptions of the deployment driving method, prediction 
methods, preferences, and buffers are provided in the subsequent sections. 

\begin{table}[]
    \centering
	\resizebox{0.7\textwidth}{!}{%
	\begin{tabular}{|l|l|p{7cm}|}
	\hline
											  & \textbf{Input Parameter}                                                           & \textbf{Examples}                                                                                                          \\ \hline
	\multirow{5}{*}{\textbf{Required}} & Demand driving commodity                                                           & Power, Fuel, Plutonium, etc.                                                                                                                      \\ \cline{2-3} 
											  & Demand equation                                                                    & P(t) = 10000, sin(t), 10000*t                                                                                                                 \\ \cline{2-3} 
											  & Facilities it controls                                                             & Fuel Fab, LWR reactor, SFR reactor, Waste repository, etc.                                                                                                      \\ \cline{2-3} 
											  & Capacities of the facilities                                                       & 3000 kg, 1000 MW, 50000 kg                                                                                                     \\ \cline{2-3} 
											  & Prediction method                                                                  & \begin{tabular}[c]{@{}l@{}}Power: fast fourier transform\\ Fuel: moving average\\ Spent fuel: moving average\end{tabular} \\ \cline{2-3} 
											  & Deployment driven by & Installed Capacity/Supply                                                                                                                    \\ \hline
	\multirow{4}{*}{\textbf{Optional}} & Supply/Capacity Buffer type                                                                        & Absolute                                                                                                                  \\ \cline{2-3} 
											  & Supply/Capacity Buffer size                                                                        & \begin{tabular}[c]{@{}l@{}}Power: 3000 MW\\ Fuel: 0 kg \\ Spent fuel: 0 kg\end{tabular}                                   \\ \cline{2-3} 
											  & Facility preferences                                                               & \begin{tabular}[c]{@{}l@{}}LWR reactor = 100-t\\ SFR reactor = t-100 \end{tabular}          \\ \cline{2-3} 
											  & Facility constraint                                                              & SFR reactor constraint = 5000kg of Pu            \\ \hline	
			
											\end{tabular}%
	}
	\caption{\deploy's required and optional input parameters with examples.}
	\label{tab:inputs}
    \end{table}

    \subsection{\textbf{Deployment Driving Method}}
    The user has the choice of deploying facilities based on the difference 
    between predicted supply and demand, or predicted demand and 
    installed capacity. 
    There are two advantages of using installed capacity over predicted 
    supply. 
    First, to prevent over deployment of facilities that have an
    intermittent supply. 
    For example, reactor facilities have a periodic refueling time. 
    A user might not want \deploy to deploy more reactor facilities 
    to make up for the lack of power supply caused by the gap in 
    supply during refueling. 
    Second, to prevent infinite deployment of a facility that uses 
    a commodity that is no longer available in the simulation. 
    For example, in a transition scenario from \gls{LWR}s to \gls{SFR}s, 
    the reprocessing plant that fabricates \gls{SFR} fuel might demand 
    Pu after the inventory accumulated by \gls{LWR}s is used up 
    and there are no more \gls{LWR} facilities to generate Pu. 
    This will result in \deploy deploying infinite reprocessing 
    facilities to generate \gls{SFR} fuel despite the lack of input Pu 
    to generate it. 
    This can be avoided by using \deploy's facility constraint capability 
    to constrain \gls{SFR} deployment until a sizable inventory of Pu 
    is accumulated in the simulation. 
    
    \subsection{\textbf{Supply/Capacity Buffer}}
    In \texttt{DemandDrivenDeploymentInst}, the user has the option 
    to provide a supply buffer for each commodity so that 
    \deploy will deploy facilities to meet predicted demand and the
    additional buffer value. 
    In \texttt{SupplyDrivenDeploymentInst}, the user has the option 
    to provide a capacity buffer to specific commodities so that 
    \deploy will deploy facilities to meet predicted supply and the
    additional buffer.
    For example, the user could set the power commodity's supply buffer 
    to be 2000 MW. 
    If predicted demand is 10000 MW, \deploy will deploy reactor 
    facilities to meet the predicted demand and supply buffer, resulting 
    in a power supply of 12000 MW.  
    The buffer can be defined as a percentage (equation \ref{eq:perc}) 
    or absolute value (equation \ref{eq:abs}). 
    
    \begin{equation}
        \label{eq:perc}
        S_{pwb} = S_{p}*(1+d)
    \end{equation}
    \begin{equation}
        \label{eq:abs}
        S_{pwb} = S_{p}+a
    \end{equation}
    where $S_{pwb}$ is predicted supply/capacity with buffer, 
    $S_p$ is the predicted supply/capacity without buffer, 
    $d$ is the percentage value in decimal form, 
    and $a$ is the absolute value of the buffer. 
    
    Using a combination of this buffer capability with the 
    installed capacity deployment driving method in a transition 
    scenario simulation is effective in minimizing undersupply of a 
    commodity without having excessive over supply. 
    This is demonstrated in section \ref{sec:demo}. 
    
    \subsection{\textbf{Preferences}}
    % Need to explain the order of preferences for deployment 
    % Constraint, pref, minimize number of facilities and minimize 
    % over supply 
    The user has the option to provide each facility with
    a time dependent preference equation that governs preference for 
    that facility compared to other facilities that provide the same 
    commodity. 
    In the example for facility preferences in table \ref{tab:inputs}, 
    the \gls{LWR} reactor has a preference of $100-t$ and the 
    \gls{SFR} reactor has a preference of $t-100$. 
    Thus, the \gls{LWR} is preferred before time step 100 and \gls{SFR}
    is preferred after. 
    
    The user also has the option to provide each facility with a 
    commodity constraint. 
    In the example for facility constraint in table \ref{tab:inputs}, 
    the \gls{SFR} has a commodity constraint of 5000kg of Pu. 
    This constrains \gls{SFR} deployment by the size of the Pu inventory 
    in the simulation. 
    Once, the 5000kg Pu inventory is first met, \gls{SFR} reactors can 
    henceforth be deployed. 
    
    One of the key issues faced in transition scenarios is the lack 
    of Pu in a scenario that results in idle advanced reactor capacity. 
    Therefore, the facility preferences and constraint capabilities 
    are useful and necessary for modeling transition scenarios. 
    An ideal transition year is selected using the facility 
    preferences, however the transition will only begin when there 
    is sufficient Pu inventory (set by facility constraint) 
    to avoid Pu shortages. 
    
    Therefore, when \deploy predicts an undersupply of a commodity, 
    it deploys available facilities to meet the predicted demand. 
    It will deploy the facility with the highest preference first, 
    unless it does not meet it's constrained criteria, then it will 
    deploy the second most, and so on. 
    If the facilities do not have preferences or constraints, \deploy 
    will deploy the available facilities to minimize the number of 
    deployed facilities while minimizing oversupply of the commodity.

\subsection{\textbf{Prediction Methods}}


\section{Sensitivity Analysis Capabilities}
In this work, \Cyclus and DYMOND are coupled with Dakota 
\cite{eldred_dakota_2010} to give the \glspl{NFCSim} \gls{SA}, 
\gls{UQ}, and optimization capabilities. 
The reason for wrapping \Cyclus and DYMOND with Dakota instead of 
using other sensitivity analysis tools (Python packages etc.)
is because Dakota is a well supported \gls{SA}, \gls{UQ}, 
and optimization tool that provides a flexible interface between 
analysis codes and iterative system analysis methods 
\cite{turner_virtual_nodate}. 
It has also previously been coupled with other nuclear engineering 
softwares \cite{turner_virtual_nodate,zhang_uncertainty_nodate}. 
The parameters for the \gls{SA}, \gls{UQ}, or optimization study is defined 
in the Dakota input file. 

The process of coupling with Dakota are similar 
for both \glspl{NFCSim}. 
The coupling is depicted in Figure \ref{fig:dakota-NFC-flow} in which 
Dakota is applied as a wrapper around each of the \glspl{NFCSim}. 
In this work, a Python interface between Dakota and the \glspl{NFCSim}
are developed. 
The Python interface has three main capabilities: 
(1) it edit the \gls{NFCSim}'s input file with Dakota's input values, 
(2) runs the simulation with the newly edited \gls{NFCSim} input file, and 
(3) reads the \gls{NFCSim}'s output file and returns values of interest 
to the Dakota output file. 
The differences in coupling lies in the python interface to each 
\gls{NFCSim}. 

\begin{figure}[]
    \centering
    \begin{tikzpicture}[node distance=4.5cm]
        \tikzstyle{every node}=[font=\large]
        \node (one) [sbblock,text width=4cm]{\small Dakota input file};
    \node (two) [bblock, right of=one, xshift = 1cm, text width=5cm]{\scriptsize Python Script\begin{itemize}
        \item Edit NFC code input file with Dakota's inputs 
        \item Run NFC code with new input file 
        \item Read NFC code database for selected output variable
    \end{itemize}};
    \node  (three) [sbblock, xshift = 1cm, right of=two,text width=4cm]{\small Dakota output file};
        
        \draw [arrow] (one) -- (two);
        \draw [arrow] (two) -- (three);
        \draw [arrow] (three) |-([shift={(0cm,-1.5cm)}]three.south west)-- ([shift={(0cm,-1.5cm)}]one.south east)-|(one);
    \end{tikzpicture}
    \caption{Depiction of coupling of Dakota and NFC code}
    \label{fig:dakota-NFC-flow}
\end{figure}

\subsection{Dymond-Dakota Coupling}
% python scripts to parse the excel input and output templates 
In the interface between Dymond and Dakota, Python is used 
to parse the excel input file to edit the relevant 
excel cells accordingly. 
Python is also used to parse the excel output database and take 
values of interest and format them to evaluate the results 
or return to the dakota output file.
The scripts coupling Dymond and Dakota are demonstrated in the 
\texttt{ddwrapper} github repository \cite{ddwrapper_doi_2019}.

\subsection{\Cyclus-Dakota Coupling}
% python scripts + jinja2 for input 
% python scripts + cymetric for output 
In the interface between \Cyclus and Dakota, 
the Jinja2 \cite{ronacher_welcome_2018} package is used 
with Python to edit the relevant parts of \Cyclus' xml input file. 
Jinja2 is a modern and designer-friendly templating 
language for Python. 
The \textsc{Cymetric} \cite{scopatz_cymetric_2015} package is used with Python 
to analyze the \Cyclus output database. 
\textsc{Cymetric} is a general analysis library and tool that was 
created in 2015 to more easily interact with \Cyclus' SQL 
database. 
The scripts coupling \Cyclus and Dakota are demonstrated in the 
\texttt{dcwrapper} github repository \cite{ddwrapper_doi_2019}.


% Add github doi 


