\chapter{Methods}
\label{chap:3}
In this chapter, we describe the nuclear fuel cycle simulators utilized in this work, 
\Cyclus and DYMOND, and the new capabilities developed for them. 
The new capabilities developed are 
(1) demand-driven deployment capabilities in \Cyclus, 
(2) sensitivity analysis capabilities for DYMOND, and
(3) sensitivity analysis capabilities for \Cyclus. 

\section{\Cyclus}
In \Cyclus, an agent-based nuclear fuel cycle simulation framework 
\cite{huff_fundamental_2016}, 
each entity (i.e. \texttt{Region}, \texttt{Institution}, or \texttt{Facility}) in the 
fuel cycle is an agent. 
\texttt{Region} agents represent geographical or political areas 
that \texttt{Institution}
and \texttt{Facility} agents reside. 
\texttt{Institution} agents control the 
deployment and decommission of \texttt{Facility} agents 
and represent legal operating organizations such as
utilities, governments, etc. \cite{huff_fundamental_2016}.
\texttt{Facility} agents represent nuclear fuel cycle facilities
such as mines, conversion facilities, reactors, reprocessing facilities, 
etc. 
\Cycamore \cite{carlsen_cycamore_2014}
provides basic \Cyclus' \texttt{Region}, \texttt{Institution}, 
and \texttt{Facility} archetypes. 
\Cyclus records isotopic mass flows and inventories at an agent-level. 

Two of \Cyclus' main design objectives are user customization and 
extensibility. 
\Cyclus' modularity, open architecture, and agent interchangeability 
achieve these objectives.
The modularity and open architecture provide users with a 
platform to develop custom facilities with their chosen fidelity 
and capabilities. 
Agent interchangeability facilitates the configuration of custom fuel 
cycles and direct comparisons of alternative modeling methodologies 
and facility concepts \cite{huff_fundamental_2016}. 
\Cyclus' input file has an XML or JSON format, and the output file is 
a SQLite or HDF5 database. 

\section{DYMOND}
DYMOND \cite{yacout_modeling_2005} is a nuclear fuel cycle simulator developed 
at Argonne National Laboratory (\gls{ANL}). 
It is built using the AnyLogic simulation software with 
Microsoft Excel templates for data input and output. 
The primary inputs to this code are time-dependent power demand, 
reactor, and fuel cycle characteristics 
\cite{feng_standardized_2016}.   
The code calls ORIGEN \cite{bell_origen_1973} during the simulation 
to conduct reactor depletion calculations. 
DYMOND records isotopic mass flows and inventories
at a system-level.
DYMOND's primary design objective is ease of understanding the  
simulator's behavior and variables. 

In DYMOND, reactor facilities are automatically deployed to 
meet user-defined power demand, and the user can define 
the percentage share of energy for up to five reactor types. 
The user also defines the fuel loading model used to calculate 
reactor spent fuel compositions, the type of reprocessing 
technology for each reactor type, and the length 
of used fuel cooling time. 
In DYMOND, the user must define the deployment schedule for 
the reprocessing plants; the cooling pools and storage pools 
are all assumed to have infinite capacities. 
DYMOND does not have demand-driven deployment capabilities for 
supporting fuel cycle facilities. 

The difference between \Cyclus and DYMOND is that \Cyclus uses 
agent-based modeling for all facilities and mass flows, 
whereas DYMOND uses fleet-based modeling for all facilities and 
mass flows except for reactor facilities. 
Compared to \Cyclus, DYMOND is easier to use but less flexible. 

\section{Demand driven deployment capability in \Cyclus (\deploy)}
In 2016, there was a push from the DOE to understand and evaluate the 
transition from the current once through LWR fuel cycle (EG01) 
to promising future end-states \cite{feng_standardized_2016}.
Previously in \Cyclus, reactor facilities were automatically 
deployed to meet user-defined power demand. 
However, the user was required to define a deployment scheme for all 
supporting facilities to avoid any supply chain 
gap resulting in idle reactor capacity. 
To avoid this issue, users 
have to set infinite capacities for the support facilities, 
but this is an inaccurate representation of reality. 
Another option is to calculate a suitable deployment schedule manually.
It is straightforward to determine a deployment scheme for a once-through 
fuel cycle manually, however, it is not straightforward for complex 
closed fuel cycle scenarios.
A nuclear fuel cycle simulator should bring demand-responsive deployment decisions into 
the simulation logic dynamics to ease setting up realistic nuclear fuel cycle 
simulations \cite{huff_current_2017}. 
Thus, a next-generation nuclear fuel cycle simulator must automate 
transition scenario setup by predictively and 
automatically deploying fuel cycle facilities to meet user-defined 
power demand. 
Therefore, the Demand-Driven Cycamore Archetypes project
(NEUP-FY16-10512) was initiated to develop demand-driven deployment 
capabilities in \Cyclus.
This capability, \deploy, is a \Cyclus \texttt{Institution}
agent that deploys facilities to meet user-defined power demand. 

\subsection{\deploy framework}
\label{sec:d3ploy}
In \Cyclus, developers have the option to design 
agents using C++ or Python. 
The \deploy \texttt{Institution} agent was 
implemented in Python to enable the use of 
well-developed time series forecasting Python packages. 

In a \Cyclus nuclear fuel cycle simulation, at every time step, \deploy 
predicts the supply and demand of each commodity for the next time 
step. 
When there exists undersupply for any commodity, 
\deploy deploys facilities to meet its predicted demand.
Figure \ref{fig:flow} shows the logic flow of \deploy 
at every time step. 

\begin{figure}[]
    \centering
    \begin{tikzpicture}[node distance=2.7cm]
        \tikzstyle{every node}=[font=\large]
        \node (Start) [bblock] {\textbf{Start timestep ($t$).}};
        \node (Predict) [bblock, below of=Start] {\textbf{Calculate \\ $D_p(t+1)$ and \\ $S_p(t+1)$ for a commodity}};
        \node (IsThere) [oblock, below of=Predict]{\textbf{$U(t+1) = S_p(t+1)-D_p(t+1)$}};
        \node (Deploy) [sbblock, below of=IsThere, xshift = -3.5cm]{\textbf{Deploy Facilities}};
        \node (NoDeploy) [sbblock, right of=Deploy, xshift = 3.5cm]{\textbf{No Deployment} };
        \node (All) [oblock, below of=Deploy, xshift = 3.5cm] {\textbf{Has $D_p(t+1)$ and $S_p(t+1)$ been calculated for all commodities?}};
        \node (End) [bblock, below of=All] {\textbf{Proceed to next timestep.}};
        
        \draw [arrow] (Start) -- (Predict); 
        \draw [arrow] (Predict) -- (IsThere);
        \draw [arrow] (IsThere) -- node[anchor=east] {$U(t+1) <$ buffer} (Deploy);
        \draw [arrow] (IsThere) -- node[anchor=west] {$U(t+1) \geq$ buffer} (NoDeploy);
        \draw [arrow] (Deploy) -- (All);
        \draw [arrow] (NoDeploy) -- (All);
        \draw [arrow] (All) -- node[anchor=west] {yes} (End);
        \draw [arrow] (All) -- ([shift={(-3.8cm,0.9cm)}]All.south west)-- node[anchor=east] {no} ([shift={(-3.8cm,-1.05cm)}]Predict.north west)--(Predict);
        \draw [arrow] (End) |-([shift={(3cm,-0.5cm)}]End.south east)-- ([shift={(3cm,0.5cm)}]Start.north east)-|(Start);
    \end{tikzpicture}
    \caption{\deploy logic flow at every timestep in \Cyclus \cite{chee_demonstration_2019}.}
    \label{fig:flow}
\end{figure}

\deploy aims to minimize the undersupply of power:
\begin{align}
	\label{eq:pow}
	obj = min \sum_{t=1}^{t_{end}} |D_{t,power}-S_{t,power}|.
\end{align} 
The sub-objectives are (1) to minimize the number of time 
steps of undersupply or under-capacity of any 
commodity: 
\begin{align}
	\label{eq:sub1}
	obj = min \sum_{i=c_1}^{c_M}\sum_{t=1}^{t_N} |D_{t,i}-S_{t,i}|,
\end{align}
,and (2) to minimize excessive oversupply of all commodities: 
\begin{align}
	\label{eq:sub2}
	obj &= min \sum_{i=c_1}^{c_M}\sum_{t=1}^{t_N} |S_{t,i}-D_{t,i}|.
	\intertext{where:}
	D &= \mbox{Demand} \nonumber\\
	S &= \mbox{Supply} \nonumber\\
	c &= \mbox{Commodity type} \nonumber\\
	M &= \mbox{Number of commmodities} \nonumber\\
	N &= \mbox{Number of time steps} \nonumber
\end{align} 
Minimizing excessive oversupply 
reflects reality in which utilities avoid 
undersupply of power on the grid by ensuring power 
plants are never short of fuel while avoiding expensive oversupply.
Nuclear fuel cycle simulators often face power undersupplies 
due to lack of viable fuel, despite having sufficient installed 
reactor capacity.  
Using \deploy to automate the deployment of supporting 
facilities prevents this. 

\subsubsection{\textbf{Structure}}
In \deploy, two distinct institutions control 
front-end and back-end fuel cycle facilities: 
\texttt{DemandDrivenDeploymentInst} and 
\texttt{SupplyDrivenDeploymentInst}, respectively. 
The reason for this distinction is that front-end facilities 
meet the demand for commodities they produce, whereas back-end 
facilities meet supply for the commodities they demand. 
For example, when a reactor facility 
demands fuel, \texttt{DemandDrivenDeploymentInst}
deploys fuel fabrication facilities to create fuel
supply. 
For back-end facilities, the reactor generates spent fuel, and 
\texttt{SupplyDrivenDeploymentInst} deploys 
waste storage facilities to create capacity to store the spent fuel. 
Figure \ref{fig:insts} depicts a simple once-through fuel cycle 
and the \texttt{Institution} type governing each 
facility's deployment.  

\begin{figure}[]
    \centering
    \resizebox{1\textwidth}{!}{
\begin{tikzpicture}[node distance=3.1cm,auto,>=latex']
	\tikzstyle{every node}=[font=\footnotesize]
    \node [bbslock] (a) {Source};
    \node [bbslock] (b) [right of=a] {Enrichment \\ Facility};
	\node [bbslock] (c) [right of=b] {Reactor};
	\node [obslock] (d) [right of=c] {Cooling \\ Pool};
	\node [obslock] (e) [right of=d] {Sink};
    \path[->] (a) edge node {Natl U} (b);
	\draw[->] (b) edge node {Fuel} (c) ;
	\draw[->] (c) edge node {\shortstack{Used \\ Fuel}} (d) ;
	\draw[->] (d) edge node {\shortstack{Cooled \\ Used \\ Fuel}} (e) ;
\end{tikzpicture}
    }
\resizebox{0.5\textwidth}{!}{
    \fbox{\begin{tabular}{ll}
        \textcolor{illiniblue}{$\blacksquare$} & Deployed by \texttt{DemandDrivenDeploymentInst}\\
        \textcolor{illiniorange}{$\blacksquare$} & Deployed by \texttt{SupplyDrivenDeploymentInst} 
		\end{tabular}}}
		\caption{Simple once-through fuel cycle depicting which facilities are deployed by 
		\texttt{DemandDrivenDeploymentInst} and \texttt{SupplyDrivenDeploymentInst}.}
\label{fig:insts}
\end{figure}

\subsubsection{\textbf{Deployment Driving Method}}
The user may deploy facilities based on the difference 
between predicted demand and predicted supply, \textit{or}
predicted demand and installed capacity. 
Using installed capacity instead of predicted supply
has two advantages. 
First, to prevent over-deployment of facilities with an
intermittent supply such as when reactors refuel. 
If predicted supply is selected instead of installed capacity, 
\deploy deploys surplus reactors during refueling downtimes to 
meet the temporary power undersupply.
Second, to prevent infinite deployment of a facility that demands 
a commodity no longer available in the simulation. 
For example, a reprocessing plant that fabricates Sodium-Cooled Fast Reactor 
(SFR) fuel might demand Pu after depletion of the existing Pu inventory and 
decommissioning of the LWR reactors that produce it, resulting in 
infinite deployment of reprocessing facilities in a futile attempt 
to produce SFR fuel. 

\subsubsection{\textbf{Input Variables}}
Table \ref{tab:inputs} lists and gives examples of the input 
variables \deploy accepts. 
The user must do the following: 
define the facilities in the simulation, their respective 
capacities, the demand driving commodity,
its demand equation, the deployment driving method, 
and the prediction method. 
The user also has the option to define supply/capacity buffers 
for individual commodities, facility preferences, and facility 
fleet shares. 
The subsequent sections describe 
the buffers, facility preferences, and prediction methods. 

\begin{table}[]
    \centering
    \doublespacing
    \caption{\deploy's required and optional input parameters with examples.}
    \label{tab:inputs}
        \small
        \begin{tabular}{l|ll}
        \hline
            & \textbf{Input Parameter}                                                           & \textbf{Examples}                                                                                                          \\ \hline
            \multirow{5}{*}{\textbf{Required}} & Demand driving commodity                                                           & Power                                                                                                                      \\ \cline{2-3} 
                                                      & Demand equation [MW]                                                                   & P(t) = 10000, sin(t), 10000*t                                                                                                                 \\ \cline{2-3} 
                                                      & Available Facilities                                                             & Fuel Fab, LWR reactor, Sink, etc.                                                                                                      \\ \cline{2-3} 
                                                      & Capacities of the facilities                                                       & 3000 kg, 1000 MW, 50000 kg                                                                                                     \\ \cline{2-3} 
                                                      & Prediction method                                                                  & \begin{tabular}[c]{@{}l@{}}Power: fast fourier transform\\ Fuel: moving average\\ Spent fuel: moving average\end{tabular} \\ \cline{2-3} 
                                                      & Deployment driven by & Installed Capacity                                                                                                                    \\ \hline
            \multirow{4}{*}{\textbf{Optional}} & Supply/Capacity Buffer type                                                                        & Absolute                                                                                                                  \\ \cline{2-3} 
                                                      & Supply/Capacity Buffer size                                                                        & \begin{tabular}[c]{@{}l@{}}Power: 3000 MW\\ Fuel: 0 kg \\ Spent fuel: 0 kg\end{tabular}                                   \\ \cline{2-3} 
                                                      & Facility preferences [month]                                                              & \begin{tabular}[c]{@{}l@{}}LWR reactor = 100-t\\ SFR reactor = t-100 \end{tabular}          \\ \cline{2-3} 
                                                      & Fleet share percentage [\%]                                                           & \begin{tabular}[c]{@{}l@{}}MOX LWR = 85\%\\ SFR = 15\% \end{tabular}          \\ \hline
                    \end{tabular}
\end{table}
    
    \subsubsection{\textbf{Supply/Capacity Buffer}}
    In \texttt{DemandDrivenDeploymentInst}, the user has the option to specify a 
    supply buffer for each commodity; \deploy accounts for the buffer when 
    calculating predicted demand and deploys facilities accordingly.
    In \texttt{SupplyDrivenDeploymentInst},
    the user has the option to specify a capacity buffer for specific 
    commodities; d3ploy accounts for the buffer when calculating predicted 
    supply and deploys facilities accordingly. 
    The buffer is defined as a percentage (equation \ref{eq:perc}) 
    or absolute value (equation \ref{eq:abs}). 
    
    \begin{align}
        \label{eq:perc}
        S_{pwb} &= S_{p}(1+d)\\
        \label{eq:abs}
        S_{pwb} &= S_{p}+a \\
        \intertext{where:}
        S_{pwb} &= \mbox{predicted supply/capacity with buffer} \nonumber\\
        S_p &= \mbox{predicted supply/capacity without buffer} \nonumber\\
        d &= \mbox{percentage value in decimal form} \nonumber\\
        a &= \mbox{absolute value of the buffer} \nonumber
    \end{align}
    For example, the user sets the power commodity's absolute supply buffer 
    to be 2000 MW and predicted demand is 10000 MW, \deploy deploys reactor 
    facilities to meet the predicted demand and supply buffer, resulting 
    in a power supply of: 
    \begin{align*}
        S_{pwb} &= S_{p}+a \\
        S_{pwb} &= 10000 \mbox{MW}+2000 \mbox{MW} \\
        &= 12000\mbox{MW}
    \end{align*}
    Using a combination of the buffer capability and  
    installed capacity deployment driving method in a transition 
    scenario simulation effectively minimizes undersupply of a 
    commodity while avoiding excessive oversupply. 
    This is demonstrated in section \ref{sec:demo}. 
    
    \subsubsection{\textbf{Facility Preference and Fleet Share}}
    The user has the option to give preferences to facilities' 
    that supply the same commodity. 
    These preferences are in the form of a time-dependent 
    equation so that the preferences are dynamic with time. 
    \deploy uses these equations to determine which facility 
    to deploy during a commodity shortage.  
    In table \ref{tab:inputs}, 
    the \gls{LWR} reactor has a preference of $100-t$, and the 
    \gls{SFR} reactor has a preference of $t-100$. 
    At time step 1, LWR preference is $99$, while SFR preference is $-99$; 
    therefore, during a commodity shortage, \deploy deploys a LWR. 
    At time step $105$, LWR preference is $-5$, while SFR preference is $5$; 
    therefore, during a commodity shortage, \deploy deploys a SFR. 

    The user also has the option to specify percentage-share for facilities 
    that provide the same commodity.   
    In table \ref{tab:inputs}, 
    the \gls{MOX} \gls{LWR} has a share of 85\%, while 
    the \gls{SFR} has a share of 15\%, constraining
    \gls{SFR} deployment to 85\% of total power demand 
    and \gls{MOX} \gls{LWR} deployment to 15\% of total power demand.  

    The year the transition begins is selected by customizing facility 
    preferences to begin preference for advanced reactors at a particular year,
    and the sharing capability determines the percentage 
    share of each type of reactor. 
    Therefore, when \deploy predicts an undersupply of a commodity, 
    it deploys facilities in order of preference, starting at 
    the highest and moving down if the facility percentage share 
    has been met. 
    If a facility type does not have any preferences, \deploy 
    deploys available facilities to minimize the number of deployed 
    facilities and oversupply of the commodity.

\subsubsection{\textbf{Prediction Methods}}
\deploy records supply and demand values at each time step for all 
commodities to provide time-series data for \deploy's time series 
forecasting methods to predict future supply and demand for each 
commodity.  
The time series forecasting methods investigated include non-optimizing, 
deterministic-optimizing, and stochastic-optimizing methods. 
Non-optimizing methods are techniques that harness 
simple moving average and autoregression concepts by using 
historical data to infer future supply and demand values. 
Deterministic-optimizing and stochastic-optimizing methods are techniques 
that use an assortment of more sophisticated time series forecasting 
concepts to predict future supply and demand values. 
Deterministic-optimizing methods give deterministic solutions,
while stochastic-optimizing methods give stochastic solutions. 

Depending on the scenario in question, each forecasting method 
offers distinct benefits and disadvantages.
The various methods are compared for each type of simulation 
to determine the most effective prediction method for 
a given scenario. 
The following sections describe the prediction methods. 

\noindent
\textit{Non-Optimizing Methods}

Non-optimizing methods include: Moving Average (\texttt{MA}), 
Autoregressive Moving Average (\texttt{ARMA}), and 
Autoregressive Heteroskedasticity (\texttt{ARCH}). 
The \texttt{MA} method calculates the average of 
a user-defined number of previous entries in a commodity's 
time series and returns it as the predicted value 
(equation \ref{eq:ma}).

\begin{align}
	\label{eq:ma}
	Predicted\ Value &= \frac{V_1+V_2+...+V_n}{n}
	\intertext{where:}
	V &= \mbox{Time series value} \nonumber\\
	n &= \mbox{length of timeseries} \nonumber\\
\end{align}

The \texttt{ARMA} method combines moving average and
autoregressive models (equation \ref{eq:arma}).
The first term is a constant, second term is 
white noise, the third term is the autoregressive
model, and the fourth term is the moving average
model.
The \texttt{ARMA} method is more accurate than the 
\texttt{MA} method 
because of the inclusion of the autoregressive term. 

\begin{align}
	\label{eq:arma}
	X_t &= c + \epsilon_t + 
	\sum_{i=1}^p\varphi_i X_{t-i} +	
	\sum_{i=1}^q\theta_i\epsilon_{t-i}
	\intertext{where:}
	c &= \mbox{constant} \nonumber\\
	\varphi &= \mbox{parameters} \nonumber\\
	\epsilon_t &= \mbox{white noise} \nonumber\\
	p &= \mbox{equation order} \nonumber \\
\end{align}

The \texttt{ARCH} method modifies the original moving 
average term (described in equation \ref{eq:arma}). 
This modification makes the \texttt{ARCH} method 
better than the \texttt{ARMA} method for volatile 
time-series data \cite{flanagan_methods_2019}. 
The StatsModels \cite{github_community_statsmodels:_2019}
Python package is used to implement \texttt{ARMA} and 
\texttt{ARCH} methods in \deploy. 

\noindent
\textit{Deterministic-Optimizing Methods}

Deterministic methods include
Fast Fourier Transform (\texttt{FFT}), 
Polynomial Fit (\texttt{POLY}), 
Exponential Smoothing (\texttt{EXP-SMOOTHING}), 
and Triple Exponential Smoothing (\texttt{HOLT-WINTERS}). 
The \texttt{FFT} method computes the discrete Fourier transform 
of the time series to predict future demand and supply 
values (equation \ref{eq:fft}).
This method is implemented in \deploy using the 
SciPy \cite{jones_scipy:_2016} Python package. 

\begin{align}
	\label{eq:fft}
	X_k &= \sum_{n=0}^{N-1}x_n e^{-i2\pi kn/N}
	\intertext{where:}
	k &= 0,...,N-1 \nonumber\\
	N &= \mbox{No. of data points} \nonumber\\
\end{align}

The \texttt{POLY} method models the time series data 
with a user-defined nth degree polynomial to determine 
future demand and supply values. 
This method was implemented in \deploy using the 
NumPy \cite{developers_numpy_2013} Python package. 
The \texttt{EXP-SMOOTHING} and \texttt{HOLT-WINTERS} 
methods use a weighted average 
of time-series data with exponentially decaying weights 
for older time series values \cite{hyndman_forecasting:_2018}
to create a model to determine future demand and supply values. 
The \texttt{EXP-SMOOTHING} method excels in 
modeling univariate time series data without trend or seasonality, 
whereas the \texttt{HOLT-WINTERS} method applies exponential 
smoothing three times, resulting in higher accuracy when 
modeling seasonal time series data. 
The StatsModels \cite{github_community_statsmodels:_2019}
Python package was used to implement both of these methods 
in \deploy. 

\noindent
\textit{Stochastic-Optimizing Methods}

There is one stochastic-optimizing method: step-wise 
seasonal method (\texttt{SW-SEASONAL}). 
The method was implemented in \deploy by the auto \gls{ARIMA} 
method in the pmdarima \cite{noauthor_pmdarima:_2019}
Python package. 
The \gls{ARIMA} model is a generalization of the \gls{ARMA}
model to make the model fit the time series data better. 

\section{Sensitivity Analysis Capabilities}
In this work, \Cyclus and DYMOND are coupled with Dakota 
\cite{eldred_dakota_2010} to give the nuclear fuel cycle simulators 
sensitivity analysis, 
uncertainty quantification, and optimization capabilities. 
Dakota is coupled with \Cyclus and DYMOND because it 
is a well supported sensitivity analysis, uncertainty quantification, 
and optimization tool that provides a flexible interface between 
analysis codes and iterative system analysis methods 
\cite{turner_virtual_nodate}. 
Other pieces of nuclear engineering software are coupled with 
Dakota to conduct sensitivity analysis
\cite{turner_virtual_nodate,zhang_uncertainty_nodate}. 

The process of coupling with Dakota is similar 
for both nuclear fuel cycle simulators. 
Figure \ref{fig:dakota-NFC-flow} depicts the coupling; 
Dakota wraps each of the nuclear fuel cycle simulators.
In this work, we developed the Python interface between 
Dakota and the nuclear fuel cycle simulators.
The Python interface has three functions: 
(1) edit the nuclear fuel cycle simulator's input file based on Dakota's input values, 
(2) run the simulation with the newly edited nuclear fuel cycle simulator's input file, and 
(3) read the nuclear fuel cycle simulator's output file and returns values of interest 
to the Dakota output file. 
The Dakota input file defines the parameters for the sensitivity analysis, 
uncertainty quantification, or optimization study.
The difference between \Cyclus and DYMOND's Python interface with Dakota is the
methods used to read and write to the input and output files. 

\begin{figure}[]
    \centering
    \resizebox{1\textwidth}{!}{
    \begin{tikzpicture}[node distance=4.5cm]
        \tikzstyle{every node}=[font=\large]
        \node (one) [sbblock,text width=4cm]{\small \textbf{Dakota Input File}};
    \node (two) [oblock, right of=one, xshift = 1cm, text width=5.3cm]{\footnotesize \textbf{Python Script}\begin{itemize}
        \item \textbf{Edit} NFC code input file with Dakota's inputs 
        \item \textbf{Run} NFC code with new input file 
        \item \textbf{Read} NFC code database for selected output variable
    \end{itemize}};
    \node  (three) [sbblock, xshift = 1cm, right of=two,text width=4cm]{\small \textbf{Dakota Output File}};
        
        \draw [arrow] (one) -- (two);
        \draw [arrow] (two) -- (three);
        \draw [arrow] (three) |-([shift={(0cm,-1.5cm)}]three.south west)-- ([shift={(0cm,-1.5cm)}]one.south east)-|(one);
    \end{tikzpicture}
    }
    \caption{Depiction of the coupling of Dakota and each nuclear fuel cycle (NFC) code.}
    \label{fig:dakota-NFC-flow}
\end{figure}

\subsection{DYMOND-Dakota Coupling (\texttt{ddwrapper})}
% python scripts to parse the excel input and output templates 
In the interface between DYMOND and Dakota, the Pywin32 
\cite{hammond_python_2000}
Python package is used to parse the Excel input file and to 
write to the relevant Excel cells accordingly. 
Pywin32 is a thin Python wrapper that enables interaction 
with COM objects \cite{hammond_python_2000}. 
The Pandas \cite{mckinney_pandas:_2011} Python
package is used to analyze the excel output database 
by taking the values of interest and formatting them 
to return to the Dakota output file.
Scripts in the \texttt{ddwrapper} Github repository \cite{chee_gwenchee/ddwrapper_2019}
demonstrate DYMOND and Dakota coupling. 

\subsection{\Cyclus-Dakota Coupling (\texttt{dcwrapper})}
In the interface between \Cyclus and Dakota, 
the Jinja2 \cite{ronacher_welcome_2018} Python package is used 
to edit the relevant parts of a \Cyclus XML input file. 
Jinja2 is a modern and designer-friendly templating 
language for Python. 
We use \textsc{Cymetric} to analyze \Cyclus' output database. 
\textsc{Cymetric} \cite{scopatz_cymetric_2015} is a general analysis library and 
tool created in 2015 to ease interaction with \Cyclus' SQL database. 
Scripts in the \texttt{dcwrapper} Github repository \cite{chee_arfc/dcwrapper_2019}
demonstrate \Cyclus and Dakota coupling. 

% Add Github doi 


